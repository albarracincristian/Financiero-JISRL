<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Presupuesto Mensual - Aplicación</title>
    <link rel="stylesheet" href="styles.css">
    <meta name="color-scheme" content="light dark">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Matriz mensual de gastos e ingresos">
</head>
<body>
    <nav>
        <ul>
            <li><a href="index.html">Panel</a></li>
            <li><a href="flujo-caja.html">Tesorería</a></li>
            <li><a href="input.html">Operaciones</a></li>
            <li><a href="data-entry.html">Presupuesto Mensual</a></li>
            <li><a href="feriados.html">Calendario Laboral</a></li>
            
        </ul>
    </nav>

    <section id="data-entry">
        <h2>Presupuesto mensual</h2>
        <p>Replica de tu planilla mensual para cargar datos y calcular totales y promedios.</p>

        <div class="toolbar">
            <button id="grid-import">Importar Excel</button>
            <button id="grid-export">Exportar Excel (Matriz)</button>
            <button id="grid-clear">Borrar Matriz</button>
            <button id="grid-add-col">Agregar columna</button>
        </div>
        <input type="file" id="grid-import-file" accept=".xlsx,.xls" style="display:none" />
        <div class="table-wrapper">
            <table id="monthly-grid" style="min-width:1100px; border-collapse:collapse; width:100%;">
                <thead id="grid-head"></thead>
                <tbody id="grid-body"></tbody>
                <tfoot id="grid-foot"></tfoot>
            </table>
        </div>

        <!-- Librería local para leer archivos Excel (.xlsx) -->
        <script src="vendor/xlsx.full.min.js"></script>

        <script>
            (function () {
                const STORAGE_KEY = 'finapp_month_grid_v1';
                const $ = (sel) => document.querySelector(sel);
                const $$ = (sel) => Array.from(document.querySelectorAll(sel));

                const months = [
                    { id: 'ENE', name: 'ENE' },
                    { id: 'FEB', name: 'FEB' },
                    { id: 'MAR', name: 'MAR' },
                    { id: 'ABR', name: 'ABR' },
                    { id: 'MAY', name: 'MAY' },
                    { id: 'JUN_SAC', name: 'JUN+SAC' },
                    { id: 'JUL', name: 'JUL' },
                    { id: 'AGO', name: 'AGO' },
                    { id: 'SEPT', name: 'SEPT' },
                    { id: 'OCT', name: 'OCT' },
                    { id: 'NOV', name: 'NOV' },
                    { id: 'DIC_SAC', name: 'DIC+SAC' },
                ];

                const baseCols = [
                    { id: 'kg', label: 'KG PEPSICO', type: 'number', currency: false },
                    { id: 'ars_total', label: 'ARS TOTAL J&I', type: 'number', currency: true },
                    { id: 'sueldos', label: 'Sueldos+F931', type: 'number', currency: true },
                    { id: 'sicore', label: 'SICORE', type: 'number', currency: true },
                    { id: 'servicios', label: 'Servicios', type: 'number', currency: true },
                    { id: 'honorarios', label: 'Honorarios', type: 'number', currency: true },
                    { id: 'gastos_grales', label: 'Gastos Generales', type: 'number', currency: true },
                    { id: 'iibb', label: 'Impuesto IIBB', type: 'number', currency: true },
                    { id: 'otros', label: 'Otros', type: 'number', currency: true },
                    { id: 'ganancias', label: 'Imp Ganancias', type: 'number', currency: true },
                    { id: 'seguros', label: 'Seguros', type: 'number', currency: true },
                    { id: 'combustibles', label: 'Combustibles', type: 'number', currency: true },
                    { id: 'iva', label: 'IVA', type: 'number', currency: true },
                    { id: 'rentas', label: 'Rentas (automotor)', type: 'number', currency: true },
                ];
                let cols = baseCols.slice();
                let totalsHeaderLabel = 'TOTALES';
                const STORAGE_TOTALS_LABEL_KEY = STORAGE_KEY + '_totals_label';
                function saveTotalsLabel() {
                    try { localStorage.setItem(STORAGE_TOTALS_LABEL_KEY, String(totalsHeaderLabel || 'TOTALES')); } catch {}
                }

                const gridHead = $('#grid-head');
                const gridBody = $('#grid-body');
                const gridFoot = $('#grid-foot');
                const importBtn = $('#grid-import');
                const importFile = $('#grid-import-file');
                const exportBtn = $('#grid-export');
                const clearBtn = $('#grid-clear');
                const addColBtn = $('#grid-add-col');

                /** @type {Record<string, Record<string, number|string|null|undefined>>} */
                let data = {};
                /** @type {{sumCols?: string[], footAst?: Record<string, any>, headerRaw?: string[], rowAst?: Record<string, any>}|null} */
                let formulaCfg = null;

                function load() {
                    try {
                        const raw = localStorage.getItem(STORAGE_KEY);
                        data = raw ? JSON.parse(raw) : {};
                    } catch { data = {}; }
                    try {
                        const rawF = localStorage.getItem(STORAGE_KEY + '_formula');
                        formulaCfg = rawF ? JSON.parse(rawF) : null;
                    } catch { formulaCfg = null; }
                }
                function save() { localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }
                function saveFormula() { localStorage.setItem(STORAGE_KEY + '_formula', JSON.stringify(formulaCfg || {})); }
                const STORAGE_COLS_KEY = STORAGE_KEY + '_cols';
                function saveCols() {
                    try {
                        const minimal = cols.map(c => ({ id: c.id, label: c.label, type: c.type || 'number', currency: !!c.currency }));
                        localStorage.setItem(STORAGE_COLS_KEY, JSON.stringify(minimal));
                    } catch {}
                }
                function loadCols() {
                    try {
                        const raw = localStorage.getItem(STORAGE_COLS_KEY);
                        if (!raw) return null;
                        const arr = JSON.parse(raw);
                        if (!Array.isArray(arr)) return null;
                        return arr.filter(x => x && x.id && x.label).map(x => ({ id: String(x.id), label: String(x.label), type: x.type || 'number', currency: !!x.currency }));
                    } catch { return null; }
                }

                function seedDefaults() {
                    // Solo carga si no hay nada guardado
                    if (data && Object.keys(data).length) return;
                    data = {
                        ENE: {
                            kg: '5026,1',
                            ars_total: '137.610.718,00',
                            sueldos: '15.982.734',
                            sicore: '1.000.000',
                            servicios: '198.766',
                            honorarios: '1.500.000',
                            gastos_grales: '866.538',
                            iibb: '4.216.693',
                            otros: '2.635.099',
                            ganancias: '499.232',
                            seguros: '64.520',
                            combustibles: '691.000',
                            iva: '',
                            rentas: '200.000',
                        },
                        FEB: {
                            kg: '4286',
                            ars_total: '119.927.612,00',
                            sueldos: '14.264.886',
                            sicore: '1.000.000',
                            servicios: '193.614',
                            honorarios: '1.500.000',
                            gastos_grales: '695.606',
                            iibb: '5.393.341',
                            otros: '452.029',
                            ganancias: '276.238',
                            seguros: '64.520',
                            combustibles: '882.000',
                            iva: '',
                            rentas: '200.000',
                        },
                        MAR: {
                            kg: '3723,1',
                            ars_total: '104.930.961,30',
                            sueldos: '14.243.095',
                            sicore: '1.000.000',
                            servicios: '192.464',
                            honorarios: '1.500.000',
                            gastos_grales: '774.593',
                            iibb: '4.723.191',
                            otros: '341.042',
                            ganancias: '763.557',
                            seguros: '64.520',
                            combustibles: '820.000',
                            iva: '',
                            rentas: '200.000',
                        },
                        ABR: {
                            kg: '4422,8',
                            ars_total: '124.821.935,00',
                            sueldos: '14.536.432',
                            sicore: '1.000.000',
                            servicios: '196.949',
                            honorarios: '1.500.000',
                            gastos_grales: '720.628',
                            iibb: '4.436.665',
                            otros: '356.229',
                            ganancias: '454.006',
                            seguros: '64.520',
                            combustibles: '892.000',
                            iva: '',
                            rentas: '200.000',
                        },
                        MAY: {
                            kg: '4590,2',
                            ars_total: '122.214.853,20',
                            sueldos: '16.129.959',
                            sicore: '1.340.052',
                            servicios: '208.311',
                            honorarios: '1.500.000',
                            gastos_grales: '1.141.428',
                            iibb: '6.800.000',
                            otros: '643.569',
                            ganancias: '754.965',
                            seguros: '149.353',
                            combustibles: '804.000',
                            iva: '',
                            rentas: '200.000',
                        },
                        JUN_SAC: {
                            kg: '4102,1',
                            ars_total: '119.857.581,70',
                            sueldos: '23.980.609',
                            sicore: '1.143.957',
                            servicios: '294.867',
                            honorarios: '1.500.000',
                            gastos_grales: '784.786',
                            iibb: '7.500.000',
                            otros: '582.747',
                            ganancias: '461.217',
                            seguros: '149.353',
                            combustibles: '776.000',
                            iva: '2.905.900',
                            rentas: '200.000',
                        },
                        JUL: {
                            kg: '4773,4',
                            ars_total: '136.449.302,20',
                            sueldos: '',
                            sicore: '1.222.172',
                            servicios: '',
                            honorarios: '',
                            gastos_grales: '',
                            iibb: '',
                            otros: '',
                            ganancias: '580.000',
                            seguros: '149.353',
                            combustibles: '',
                            iva: '400.000',
                            rentas: '200.000',
                        },
                    };
                    save();
                }

                function toCurrency(n) {
                    return new Intl.NumberFormat('es-AR', { style: 'currency', currency: 'ARS', maximumFractionDigits: 0 }).format(n || 0);
                }
                function toNumberFormat(n) {
                    return new Intl.NumberFormat('es-AR', { maximumFractionDigits: 1 }).format(n || 0);
                }
                function parseNum(s) {
                    if (s === undefined || s === null) return null;
                    const str = String(s).trim();
                    if (!str) return null;
                    // acepta 1.234.567,89 o 1234567.89
                    const norm = str.replace(/[^0-9,.-]/g, '')
                                    .replace(/\.(?=\d{3}(\D|$))/g, '')
                                    .replace(',', '.');
                    const n = Number(norm);
                    return Number.isFinite(n) ? n : null;
                }

                // Utilidad para renderizar encabezados seguros
                function escapeHtml(str) {
                    return String(str)
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                }

                function toTitleCase(str) {
                    try {
                        const lower = String(str ?? '').toLocaleLowerCase('es-AR');
                        return lower.replace(/(^|[\s\-_/+&()])[\p{L}]/gu, m => m.toLocaleUpperCase('es-AR'));
                    } catch {
                        const lower = String(str ?? '').toLowerCase();
                        return lower.replace(/(^|[\s\-_/+&()])[a-z]/g, s => s.toUpperCase());
                    }
                }

                function renderHead() {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<th style="position:sticky; left:0; background:var(--bg,#fff); z-index:1;">${escapeHtml(toTitleCase('Mes'))}</th>` +
                        cols.map(c => `
                            <th data-col="${c.id}">
                                <span class="col-label">${escapeHtml(toTitleCase(c.label))}</span>
                                <span class="col-actions" aria-hidden="true">
                                    <button type="button" class="col-act" data-action="rename" title="Renombrar" aria-label="Renombrar">?</button>
                                    <button type="button" class="col-act danger" data-action="delete" title="Eliminar" aria-label="Eliminar">×</button>
                                </span>
                            </th>
                        `).join('') +
                        `<th>${escapeHtml(toTitleCase(totalsHeaderLabel))}</th>`;
                    gridHead.innerHTML = '';
                    gridHead.appendChild(tr);
                }

                function rowTotal(monthId) {
                    const row = data[monthId] || {};
                    let sum = 0;
                    const ids = (formulaCfg && Array.isArray(formulaCfg.sumCols) && formulaCfg.sumCols.length)
                        ? formulaCfg.sumCols
                        : cols.filter(c => c.id !== 'kg' && c.id !== 'ars_total').map(c => c.id);
                    for (const cId of ids) {
                        const v = parseNum(row[cId]);
                        if (v !== null) sum += v;
                    }
                    return sum;
                }

                function renderBody() {
                    gridBody.innerHTML = '';
                    for (const m of months) {
                        const tr = document.createElement('tr');
                        const sticky = `<th style=\"position:sticky; left:0; background:var(--bg,#fff);\">${m.name}</th>`;
                        const cells = cols.map(c => {
                            const isComputed = !!(formulaCfg && formulaCfg.rowAst && formulaCfg.rowAst[c.id]);
                            let display = data[m.id]?.[c.id] ?? '';
                            if (isComputed) {
                                try { evalAst.currentColId = c.id; evalAst.currentMonthId = m.id; display = String(evalAst(formulaCfg.rowAst[c.id])); } catch { /* noop */ } finally { evalAst.currentColId = null; evalAst.currentMonthId = null; }
                                if (!data[m.id]) data[m.id] = {};
                                data[m.id][c.id] = display;
                            }
                            const ro = isComputed ? 'readonly data-computed="true" style="background:var(--computed-bg,#f2f2f2);"' : '';
                            // Formato moneda para columnas de dinero (excepto KG)
                            let attrCurrency = '';
                            let valueForInput = display;
                            if (c.currency) {
                                attrCurrency = 'data-currency="1"';
                                const n = parseNum(display);
                                valueForInput = n === null ? '' : toCurrency(n);
                            }
                            return `<td><input class=\"grid-input\" ${attrCurrency} data-month=\"${m.id}\" data-field=\"${c.id}\" type=\"text\" inputmode=\"decimal\" value=\"${valueForInput}\" ${ro}></td>`;
                        }).join('');
                        const total = rowTotal(m.id);
                        const totalClass = total > 0 ? 'positive' : 'zero';
                        tr.innerHTML = sticky + cells + `<td class=\"row-total ${totalClass}\" data-total-for=\"${m.id}\">${toCurrency(total)}</td>`;
                        gridBody.appendChild(tr);
                    }
                }

                function renderFoot() {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<th>Promedio</th>` + cols.map(c => {
                        let value;
                        if (formulaCfg && formulaCfg.footAst && formulaCfg.footAst[c.id]) {
                            try { evalAst.currentColId = c.id; value = evalAst(formulaCfg.footAst[c.id]); } catch { value = null; } finally { evalAst.currentColId = null; }
                        }
                        if (value == null) {
                            const vals = months.map(m => parseNum(data[m.id]?.[c.id])).filter(v => v !== null);
                            value = vals.length ? (vals.reduce((a,b)=>a+b,0) / vals.length) : 0;
                        }
                        return `<td class=\"foot-cell\">${c.currency ? toCurrency(value) : toNumberFormat(value)}</td>`;
                    }).join('') + (() => {
                        const totals = months.map(m => rowTotal(m.id)).filter(v => v > 0);
                        const avgT = totals.length ? (totals.reduce((a,b)=>a+b,0) / totals.length) : 0;
                        return `<td class=\"foot-cell foot-total\">${toCurrency(avgT)}</td>`;
                    })();
                    gridFoot.innerHTML = '';
                    gridFoot.appendChild(tr);
                }

                function renderAll() { renderHead(); renderBody(); renderFoot(); }

                function handleChange(ev) {
                    const input = ev.target.closest('input.grid-input');
                    if (!input) return;
                    const month = input.getAttribute('data-month');
                    const field = input.getAttribute('data-field');
                    const val = input.value;
                    if (!data[month]) data[month] = {};
                    data[month][field] = val; // guardamos tal cual escribe
                    save();
                    // Recalcular campos computados de la misma fila
                    recomputeRow(month);
                    // Actualizamos total de fila y promedios
                    const totalCell = gridBody.querySelector(`td.row-total[data-total-for="${month}"]`);
                    if (totalCell) totalCell.textContent = toCurrency(rowTotal(month));
                    renderFoot();
                }

                gridBody.addEventListener('input', handleChange);
                // Navegación con Enter: moverse a la próxima columna en la misma fila
                function focusGridCell(monthId, colId) {
                    const sel = `input.grid-input[data-month="${monthId}"][data-field="${colId}"]`;
                    const next = gridBody.querySelector(sel);
                    if (next) {
                        next.focus();
                        try { next.select(); } catch {}
                        try { next.scrollIntoView({ block: 'nearest', inline: 'nearest' }); } catch {}
                    }
                }
                function moveRightFrom(inputEl) {
                    const field = inputEl.getAttribute('data-field');
                    const monthId = inputEl.getAttribute('data-month');
                    const colIdx = cols.findIndex(c => c.id === field);
                    if (colIdx === -1) return;
                    // Intentar moverse a la derecha en la misma fila
                    for (let i = colIdx + 1; i < cols.length; i++) {
                        const nextId = cols[i].id;
                        const sel = `input.grid-input[data-month="${monthId}"][data-field="${nextId}"]`;
                        const cand = gridBody.querySelector(sel);
                        if (cand && !cand.readOnly) { focusGridCell(monthId, nextId); return; }
                    }
                    // Wrap-around: primera columna editable de la fila siguiente
                    let rowIdx = months.findIndex(m => m.id === monthId);
                    if (rowIdx === -1) return;
                    rowIdx = (rowIdx + 1) % months.length;
                    const nextMonthId = months[rowIdx].id;
                    for (let i = 0; i < cols.length; i++) {
                        const nextId = cols[i].id;
                        const sel = `input.grid-input[data-month="${nextMonthId}"][data-field="${nextId}"]`;
                        const cand = gridBody.querySelector(sel);
                        if (cand && !cand.readOnly) { focusGridCell(nextMonthId, nextId); return; }
                    }
                }
                gridBody.addEventListener('keydown', (ev) => {
                    const input = ev.target && ev.target.closest && ev.target.closest('input.grid-input');
                    if (!input) return;
                    if (ev.key === 'Enter') {
                        ev.preventDefault();
                        moveRightFrom(input);
                    }
                });

                // Dar una experiencia de ediciÃ³n cÃ³moda para moneda
                function unformatCurrencyDisplay(input) {
                    const n = parseNum(input.value);
                    input.value = (n === null || !Number.isFinite(n)) ? '' : String(n);
                }
                function formatCurrencyDisplay(input) {
                    const n = parseNum(input.value);
                    input.value = (n === null || !Number.isFinite(n)) ? '' : toCurrency(n);
                }
                gridBody.addEventListener('focusin', (ev) => {
                    const input = ev.target.closest('input.grid-input[data-currency="1"]');
                    if (input && !input.readOnly) unformatCurrencyDisplay(input);
                });
                gridBody.addEventListener('focusout', (ev) => {
                    const input = ev.target.closest('input.grid-input[data-currency="1"]');
                    if (input) formatCurrencyDisplay(input);
                });

                importBtn.addEventListener('click', () => importFile.click());

                // Acciones de encabezado (renombrar/eliminar columna)
                gridHead.addEventListener('click', (ev) => {
                    const btn = ev.target.closest('button.col-act');
                    if (!btn) return;
                    const th = btn.closest('th[data-col]');
                    const colId = th ? th.getAttribute('data-col') : null;
                    if (!colId) return;
                    const idx = cols.findIndex(c => c.id === colId);
                    if (idx === -1) return;
                    const action = btn.getAttribute('data-action');
                    if (action === 'rename') {
                        const current = cols[idx].label || cols[idx].id;
                        const name = prompt('Nuevo nombre de columna:', current);
                        if (!name || !String(name).trim()) return;
                        cols[idx].label = String(name).trim();
                        saveCols();
                        renderAll();
                    } else if (action === 'delete') {
                        if (!confirm('¿Eliminar esta columna de la matriz?')) return;
                        const removed = cols.splice(idx, 1)[0];
                        // Quitar de sumCols si estuviera
                        if (formulaCfg && Array.isArray(formulaCfg.sumCols)) {
                            formulaCfg.sumCols = formulaCfg.sumCols.filter(id => id !== removed.id);
                            saveFormula();
                        }
                        saveCols();
                        renderAll();
                    }
                });

                // Agregar columna dinámica
                function slugFromLabel(label) {
                    let s = String(label || '').trim();
                    try { s = s.normalize('NFD').replace(/\p{Diacritic}/gu, ''); } catch {}
                    s = s.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
                    if (!s) s = 'col';
                    let base = s; let i = 1;
                    const exists = (id) => cols.some(c => c.id === id) || baseCols.some(c => c.id === id);
                    while (exists(s)) { i++; s = base + '_' + i; }
                    return s;
                }

                addColBtn.addEventListener('click', () => {
                    const label = prompt('Nombre de la nueva columna:', 'Nueva columna');
                    if (!label || !String(label).trim()) return;
                    const isCurrency = confirm('¿Formatear como moneda (ARS)?');
                    const id = slugFromLabel(label);
                    cols.push({ id, label: String(label).trim(), type: 'number', currency: !!isCurrency });
                    // Incluir en TOTALES si hay config explícita
                    if (formulaCfg && Array.isArray(formulaCfg.sumCols)) {
                        if (!formulaCfg.sumCols.includes(id)) {
                            formulaCfg.sumCols.push(id);
                            saveFormula();
                        }
                    }
                    saveCols();
                    renderAll();
                });

                importFile.addEventListener('change', (ev) => {
                    const file = importFile.files && importFile.files[0];
                    if (!file) return;
                    const name = (file.name || '').toLowerCase();
                    const reader = new FileReader();
                    if (!(name.endsWith('.xlsx') || name.endsWith('.xls'))) {
                        alert('Selecciona un archivo Excel (.xlsx / .xls).');
                        importFile.value = '';
                        return;
                    }
                    reader.onload = () => {
                        try {
                            if (typeof XLSX === 'undefined') throw new Error('Librería XLSX no cargada');
                            const dataArr = new Uint8Array(/** @type {ArrayBuffer} */ (reader.result));
                            const wb = XLSX.read(dataArr, { type: 'array' });
                            const chosen = pickSheetName(wb);
                            const ws = wb.Sheets[chosen];
                            const rows = XLSX.utils.sheet_to_json(ws, { header: 1, raw: false });
                            try { formulaCfg = extractFormulaConfigFromSheet(ws, rows); saveFormula(); } catch(e) { console.warn('No se extrajo config de fÃ³rmulas:', e); }
                            applyImportedRows(rows);
                            save();
                            renderAll();
                            alert(`Importación desde Excel completada (hoja: ${chosen}).`);
                        } catch (e) {
                            console.error(e);
                            alert('No se pudo importar el Excel. Verifica la estructura.');
                        } finally { importFile.value = ''; }
                    };
                    reader.readAsArrayBuffer(file);
                });

                exportBtn.addEventListener('click', () => {
                    if (typeof XLSX === 'undefined') { alert('Falta la Librería de Excel.'); return; }
                    const header = [toTitleCase('Mes'), ...cols.map(c => toTitleCase(c.label)), toTitleCase(totalsHeaderLabel)];
                    // Guardar etiqueta de Totales utilizada en export
                    try { saveTotalsLabel(); } catch {}
                    const body = months.map(m => {
                        const row = data[m.id] || {};
                        const cells = cols.map(c => {
                            const n = parseNum(row[c.id]);
                            return n === null ? '' : n;
                        });
                        return [m.name, ...cells, rowTotal(m.id)];
                    });
                    // Fila de promedio
                    const foot = ['Promedio', ...cols.map(c => {
                        let value;
                        if (formulaCfg && formulaCfg.footAst && formulaCfg.footAst[c.id]) {
                            try { evalAst.currentColId = c.id; value = evalAst(formulaCfg.footAst[c.id]); } catch { value = null; } finally { evalAst.currentColId = null; }
                        }
                        if (value == null) {
                            const vals = months.map(m => parseNum(data[m.id]?.[c.id])).filter(v => v !== null);
                            value = vals.length ? (vals.reduce((a,b)=>a+b,0) / vals.length) : 0;
                        }
                        return value;
                    }), (() => {
                        const totals = months.map(m => rowTotal(m.id)).filter(v => v > 0);
                        return totals.length ? (totals.reduce((a,b)=>a+b,0) / totals.length) : 0;
                    })()];

                    const aoa = [header, ...body, foot];
                    const ws = XLSX.utils.aoa_to_sheet(aoa);

                    // Establecer anchos de columna y formatos
                    const colCount = header.length;
                    const colMeta = [{ wch: 10 }]; // MES
                    for (let i = 0; i < cols.length; i++) {
                        // ancho por defecto 18, algunos mÃ¡s angostos
                        const base = 18;
                        colMeta.push({ wch: Math.max(base, String(header[i+1]||'').length + 2) });
                    }
                    colMeta.push({ wch: 16 }); // Totales
                    ws['!cols'] = colMeta;

                    // Formatos numÃ©ricos: kg con una decima; moneda/demÃ¡s enteros con separador
                    const fmtKg = '#,##0.0';
                    const fmtInt = '#,##0';
                    function cellAt(r, c) { const addr = XLSX.utils.encode_cell({ r, c }); return ws[addr]; }

                    // Rutas: fila 0 = header; filas 1..months = datos; Ãúltima fila = foot
                    const firstDataRow = 1;
                    const lastDataRow = firstDataRow + months.length - 1;
                    const lastColIndex = colCount - 1;

                    // Recorrer datos para setear formato
                    for (let r = firstDataRow; r <= lastDataRow; r++) {
                        // Col KG (col 1)
                        const cKg = 1;
                        const ck = cellAt(r, cKg); if (ck && typeof ck.v === 'number') ck.z = fmtKg;
                        // Columnas de valores
                        for (let ci = 2; ci < colCount; ci++) {
                            const cell = cellAt(r, ci);
                            if (cell && typeof cell.v === 'number') cell.z = fmtInt;
                        }
                    }
                    // Fila de promedio (Ãúltima)
                    const footRow = lastDataRow + 1;
                    for (let ci = 1; ci < colCount; ci++) {
                        const cell = cellAt(footRow, ci);
                        if (!cell) continue;
                        cell.z = (ci === 1) ? fmtKg : fmtInt;
                    }

                    // Agregar autofiltro y congelar encabezados (si el lector soporta la propiedad)
                    ws['!autofilter'] = { ref: XLSX.utils.encode_range({ s: { r: 0, c: 0 }, e: { r: 0, c: lastColIndex } }) };
                    try { ws['!freeze'] = { rows: 1, columns: 1 }; } catch {}

                    const wb = XLSX.utils.book_new();
                    XLSX.utils.book_append_sheet(wb, ws, 'Matriz');

                    // Hoja de Resumen por rubro
                    const summaryHeader = ['Rubro', 'Total', 'Promedio', 'MÃ¡ximo', 'MÃ­nimo'];
                    const summaryBody = cols.map(c => {
                        const vals = months.map(m => parseNum(data[m.id]?.[c.id])).filter(v => v !== null);
                        const total = vals.reduce((a,b)=>a+b,0);
                        const avg = vals.length ? total / vals.length : 0;
                        const max = vals.length ? Math.max(...vals) : 0;
                        const min = vals.length ? Math.min(...vals) : 0;
                        return [c.label, total, avg, max, min];
                    });
                    const ws2 = XLSX.utils.aoa_to_sheet([summaryHeader, ...summaryBody]);
                    // Anchos y formatos
                    ws2['!cols'] = [
                        { wch: 28 }, { wch: 16 }, { wch: 16 }, { wch: 16 }, { wch: 16 }
                    ];
                    for (let r = 1; r <= summaryBody.length; r++) {
                        for (let c = 1; c <= 4; c++) {
                            const cell = ws2[XLSX.utils.encode_cell({ r, c })];
                            if (cell && typeof cell.v === 'number') cell.z = '#,##0';
                        }
                    }
                    try { ws2['!freeze'] = { rows: 1 }; } catch {}
                    XLSX.utils.book_append_sheet(wb, ws2, 'Resumen');
                    const filename = `matriz-mensual-${new Date().toISOString().slice(0,10)}.xlsx`;
                    XLSX.writeFile(wb, filename);
                });

                clearBtn.addEventListener('click', () => {
                    if (confirm('Esto borrarÃ¡ la matriz mensual. Â¿Continuar?')) {
                        data = {};
                        save();
                        renderAll();
                    }
                });

                // Init
                load();
                // Intentar cargar columnas guardadas y fusionarlas
                const savedCols = loadCols();
                // Aplicar encabezados guardados, si existen
                try {
                    if (formulaCfg && Array.isArray(formulaCfg.headerRaw)) {
                        const headerRaw = formulaCfg.headerRaw;
                        const headerNorm = headerRaw.map(normalizeLabel);
                        const wantMap = Object.fromEntries(baseCols.map(c => [normalizeLabel(c.label), c.id]));
                        const newCols = [];
                        for (let c = 0; c < headerNorm.length; c++) {
                            const norm = headerNorm[c];
                            if (norm === 'MES' || norm === 'TOTALES') continue;
                            const id = wantMap[norm];
                            if (id) {
                                const base = baseCols.find(x => x.id === id);
                                newCols.push({ ...base, label: headerRaw[c] || base.label });
                            }
                        }
                        for (const bc of baseCols) {
                            if (!newCols.some(x => x.id === bc.id)) newCols.push(bc);
                        }
                        cols = newCols;
                        // Anexar columnas personalizadas guardadas (no presentes en base/header)
                        if (savedCols && savedCols.length) {
                            const known = new Set(cols.map(c => c.id));
                            for (const sc of savedCols) { if (!known.has(sc.id)) cols.push(sc); }
                        }
                        const idxTot = headerNorm.findIndex(h => h === 'TOTALES');
                        totalsHeaderLabel = idxTot >= 0 ? headerRaw[idxTot] : 'TOTALES';
                        try { saveTotalsLabel(); } catch {}
                    }
                } catch {}
                // Si no hab?a headerRaw pero s? existen columnas guardadas, anexarlas
                if ((!formulaCfg || !Array.isArray(formulaCfg.headerRaw)) && savedCols && savedCols.length) {
                    const known = new Set(cols.map(c => c.id));
                    for (const sc of savedCols) { if (!known.has(sc.id)) cols.push(sc); }
                }
                // Fusionar etiquetas y flags de columnas guardadas en las existentes
                if (savedCols && savedCols.length) {
                    const byId = Object.fromEntries(cols.map(c => [c.id, c]));
                    for (const sc of savedCols) {
                        if (byId[sc.id]) {
                            if (sc.label) byId[sc.id].label = sc.label;
                            if (typeof sc.currency === 'boolean') byId[sc.id].currency = sc.currency;
                        }
                    }
                }
                // Si no vino de Excel un header para TOTALES, cargar etiqueta guardada (si existe)
                try {
                    const savedTot = localStorage.getItem(STORAGE_TOTALS_LABEL_KEY);
                    if (savedTot && String(savedTot).trim()) totalsHeaderLabel = String(savedTot);
                } catch {}
                seedDefaults();
                renderAll();

                // --- Utilidades de Importación CSV ---
                function normalizeLabel(s) {
                    if (!s) return '';
                    let out = String(s).trim();
                    try { out = out.normalize('NFD').replace(/\p{Diacritic}/gu, ''); } catch {}
                    out = out.replace(/[^a-zA-Z0-9]/g, '').toUpperCase();
                    return out;
                }

                function pickSheetName(wb) {
                    try {
                        const names = wb.SheetNames || [];
                        if (names.length <= 1) return names[0];
                        // Buscar hojas cuyo header contenga MES
                        const candidates = [];
                        for (const n of names) {
                            const ws = wb.Sheets[n];
                            const rows = XLSX.utils.sheet_to_json(ws, { header: 1, raw: false });
                            const header = Array.isArray(rows?.[0]) ? rows[0] : [];
                            const hasMes = header.some(c => normalizeLabel(c) === 'MES');
                            if (hasMes) candidates.push(n);
                        }
                        if (candidates.length === 1) return candidates[0];
                        const list = (candidates.length ? candidates : names).map((n, i) => `${i+1}) ${n}`).join('\n');
                        const input = prompt(`El archivo tiene varias hojas. ElegÃ­ una escribiendo el nÃºmero:\n${list}`, '1');
                        const idx = Math.max(1, Math.min((candidates.length ? candidates : names).length, parseInt(String(input || '1'), 10))) - 1;
                        return (candidates.length ? candidates : names)[idx];
                    } catch {
                        return wb.SheetNames[0];
                    }
                }

                function extractFormulaConfigFromSheet(ws, rows) {
                    // Header
                    // Detectar fila de encabezado con 'MES'
                    let hRow = 0;
                    for (let r = 0; r < Math.min(rows.length, 15); r++) {
                        const rnorm = (rows[r] || []).map(normalizeLabel);
                        if (rnorm.includes('MES')) { hRow = r; break; }
                    }
                    const header = Array.isArray(rows?.[hRow]) ? rows[hRow] : [];
                    const normHeader = header.map(normalizeLabel);
                    const idxMes = normHeader.indexOf('MES');
                    const idxTotal = normHeader.indexOf('TOTALES');

                    // Mapeo de columna header -> id propio
                    const idByNormHeader = Object.fromEntries(baseCols.map(c => [normalizeLabel(c.label), c.id]));

                    // Detectar columnas incluidas en TOTALES
                    let sumCols = cols.filter(c => c.id !== 'kg' && c.id !== 'ars_total').map(c => c.id);
                    if (idxTotal !== -1) {
                        // primera fila con datos
                        let dataRowIdx = hRow + 1;
                        while (dataRowIdx < rows.length && (!rows[dataRowIdx] || rows[dataRowIdx].every(v => String(v||'').trim() === ''))) dataRowIdx++;
                        const cellAddr = XLSX.utils.encode_cell({ r: dataRowIdx, c: idxTotal });
                        const cell = ws[cellAddr];
                        const f = cell && cell.f ? String(cell.f).toUpperCase().replace(/\$/g, '') : '';
                        const m = f.match(/SUM[A]?\(([^\)]+)\)/);
                        if (m) {
                            const range = m[1].split(',')[0].trim();
                            try {
                                const drg = XLSX.utils.decode_range(range);
                                const includedColIdxs = [];
                                for (let c = drg.s.c; c <= drg.e.c; c++) includedColIdxs.push(c);
                                const includedIds = includedColIdxs.map(cIdx => idByNormHeader[normHeader[cIdx]]).filter(Boolean);
                                if (includedIds.length) sumCols = includedIds;
                            } catch {}
                        }
                    }

                    // Construir mapa de fila->mes segÃºn columna MES del Excel
                    const alias = {
                        'ENE': 'ENE','ENERO':'ENE',
                        'FEB':'FEB','FEBRERO':'FEB',
                        'MAR':'MAR','MARZO':'MAR',
                        'ABR':'ABR','ABRIL':'ABR',
                        'MAY':'MAY','MAYO':'MAY',
                        'JUN':'JUN','JUNIO':'JUN','JUNSAC':'JUN_SAC','JUN+SAC':'JUN_SAC',
                        'JUL':'JUL','JULIO':'JUL',
                        'AGO':'AGO','AGOSTO':'AGO',
                        'SEP':'SEPT','SEPT':'SEPT','SEPTIEMBRE':'SEPT',
                        'OCT':'OCT','OCTUBRE':'OCT',
                        'NOV':'NOV','NOVIEMBRE':'NOV',
                        'DIC':'DIC','DICIEMBRE':'DIC','DICSAC':'DIC_SAC','DIC+SAC':'DIC_SAC'
                    };
                    const rowToMonth = {};
                    if (idxMes !== -1) {
                        for (let r = hRow + 1; r < rows.length; r++) {
                            const v = rows[r]?.[idxMes];
                            const k = alias[normalizeLabel(v)];
                            if (k) rowToMonth[r] = k;
                        }
                    }

                    // Detectar fila de Promedio y fÃ³rmulas de pie por columna
                    let footRowIdx = -1;
                    for (let r = rows.length - 1; r >= 0; r--) {
                        const row = rows[r] || [];
                        if (row.some(c => normalizeLabel(c) === 'PROMEDIO')) { footRowIdx = r; break; }
                    }
                    const footAst = {};
                    if (footRowIdx !== -1) {
                        for (let c = 0; c < normHeader.length; c++) {
                            const id = idByNormHeader[normHeader[c]];
                            if (!id) continue;
                            const addr = XLSX.utils.encode_cell({ r: footRowIdx, c });
                            const cell = ws[addr];
                            if (!cell || !cell.f) continue;
                            try {
                                const ast = parseExcelFooterFormula(cell.f, rowToMonth, c);
                                if (ast) footAst[id] = ast;
                            } catch (e) { console.warn('No se pudo parsear fÃ³rmula de pie en col', id, e); }
                        }
                    }

                    // Detectar fÃ³rmulas por fila en primera fila de datos
                    const rowAst = {};
                    if (rows && rows.length) {
                        let dataRowIdx2 = 1;
                        while (dataRowIdx2 < rows.length && (!rows[dataRowIdx2] || rows[dataRowIdx2].every(v => String(v||'').trim() === ''))) dataRowIdx2++;
                        for (let c = 0; c < normHeader.length; c++) {
                            const id = idByNormHeader[normHeader[c]];
                            if (!id) continue;
                            if (normHeader[c] === 'MES' || normHeader[c] === 'TOTALES') continue;
                            const addr = XLSX.utils.encode_cell({ r: dataRowIdx2, c });
                            const cell = ws[addr];
                            if (!cell || !cell.f) continue;
                            try {
                                const ast = parseExcelRowFormula(cell.f, normHeader, idByNormHeader, dataRowIdx2);
                                if (ast) rowAst[id] = ast;
                            } catch (e) { console.warn('No se pudo parsear fÃ³rmula de fila en col', id, e); }
                        }
                    }

                    return { sumCols, footAst, rowAst };
                }

                // Parser para fÃ³rmulas por fila: referencias dentro de la misma fila
                function parseExcelRowFormula(formula, normHeader, idByNormHeader, rowIdx0) {
                    const src = String(formula).replace(/\s+/g, '').replace(/\$/g, '').toUpperCase();
                    const TOK = { NUM:'NUM', ID:'ID', OP:'OP', LP:'LP', RP:'RP', COMMA:'COMMA', COLON:'COLON' };
                    function* tokenize(s) {
                        let i = 0;
                        while (i < s.length) {
                            const ch = s[i];
                            if (/[0-9.]/.test(ch)) { let j=i; while(j<s.length && /[0-9.]/.test(s[j])) j++; yield {t:TOK.NUM, v:s.slice(i,j)}; i=j; continue; }
                            if (/[A-Z_]/.test(ch)) { let j=i; while(j<s.length && /[A-Z0-9_]/.test(s[j])) j++; yield {t:TOK.ID, v:s.slice(i,j)}; i=j; continue; }
                            if (ch === '+' || ch === '-' || ch === '*' || ch === '/') { yield {t:TOK.OP, v:ch}; i++; continue; }
                            if (ch === '(') { yield {t:TOK.LP}; i++; continue; }
                            if (ch === ')') { yield {t:TOK.RP}; i++; continue; }
                            if (ch === ',') { yield {t:TOK.COMMA}; i++; continue; }
                            if (ch === ':') { yield {t:TOK.COLON}; i++; continue; }
                            i++;
                        }
                    }
                    const tokens = Array.from(tokenize(src));
                    let pos = 0;
                    const peek = () => tokens[pos];
                    const consume = () => tokens[pos++];

                    function parse() { return parseExpr(); }
                    function parseExpr() { let n = parseTerm(); while (peek() && peek().t===TOK.OP && (peek().v==='+'||peek().v==='-')){const op=consume().v; n={type:'op',op,args:[n,parseTerm()]};} return n; }
                    function parseTerm() { let n = parseFactor(); while (peek() && peek().t===TOK.OP && (peek().v==='*'||peek().v==='/')){const op=consume().v; n={type:'op',op,args:[n,parseFactor()]};} return n; }
                    function parseFactor() {
                        const tk = peek(); if (!tk) return {type:'const', value:0};
                        if (tk.t===TOK.NUM){ consume(); return {type:'const', value:Number(tk.v)}; }
                        if (tk.t===TOK.ID){
                            const a = consume(); const next = peek();
                            if (next && next.t===TOK.NUM){ // celda C2
                                const aRow = parseInt(consume().v,10)-1;
                                if (peek() && peek().t===TOK.COLON){ // rango C2:O2
                                    consume(); const bId = consume(); const bRowTk = consume(); if (!bId||bId.t!==TOK.ID||!bRowTk||bRowTk.t!==TOK.NUM) return {type:'const',value:null};
                                    const bRow = parseInt(bRowTk.v,10)-1; if (aRow!==rowIdx0 || bRow!==rowIdx0) return {type:'const', value:null};
                                    const c1 = XLSX.utils.decode_col(a.v); const c2 = XLSX.utils.decode_col(bId.v);
                                    const ids = []; for(let c=Math.min(c1,c2); c<=Math.max(c1,c2); c++){ const id = idByNormHeader[normHeader[c]]; if (id) ids.push(id); }
                                    return { type:'rowRange', cols: ids };
                                } else {
                                    if (aRow!==rowIdx0) return {type:'const', value:null};
                                    const c1 = XLSX.utils.decode_col(a.v); const id = idByNormHeader[normHeader[c1]]; return { type:'rowCell', colId: id };
                                }
                            }
                            if (next && next.t===TOK.LP){
                                consume(); const args=[]; if (peek() && peek().t!==TOK.RP){ args.push(parse()); while (peek() && peek().t===TOK.COMMA){ consume(); args.push(parse()); } } if (peek() && peek().t===TOK.RP) consume();
                                return { type:a.v, args };
                            }
                            return {type:'const', value:0};
                        }
                        if (tk.t===TOK.LP){ consume(); const node=parse(); if (peek() && peek().t===TOK.RP) consume(); return node; }
                        return {type:'const', value:0};
                    }
                    return parse();
                }

                // --- Parser/Evaluator simple para fÃ³rmulas de pie ---
                function parseExcelFooterFormula(formula, rowToMonth, colIdx) {
                    // Parser con operadores + - * /, parÃ©ntesis y funciones SUM/SUMA, PROMEDIO/AVERAGE, MAX, MIN.
                    const src = String(formula).replace(/\s+/g, '').replace(/\$/g, '').toUpperCase();

                    // Tokenizador simple
                    const TOK = { NUM:'NUM', ID:'ID', OP:'OP', LP:'LP', RP:'RP', COMMA:'COMMA', COLON:'COLON' };
                    function* tokenize(s) {
                        let i = 0;
                        while (i < s.length) {
                            const ch = s[i];
                            if (/[0-9.]/.test(ch)) { let j=i; while(j<s.length && /[0-9.]/.test(s[j])) j++; yield {t:TOK.NUM, v:s.slice(i,j)}; i=j; continue; }
                            if (/[A-Z_]/.test(ch)) { let j=i; while(j<s.length && /[A-Z0-9_]/.test(s[j])) j++; yield {t:TOK.ID, v:s.slice(i,j)}; i=j; continue; }
                            if (ch === '+ '|| ch === '-' || ch === '*' || ch === '/') { yield {t:TOK.OP, v:ch}; i++; continue; }
                            if (ch === '(') { yield {t:TOK.LP}; i++; continue; }
                            if (ch === ')') { yield {t:TOK.RP}; i++; continue; }
                            if (ch === ',') { yield {t:TOK.COMMA}; i++; continue; }
                            if (ch === ':') { yield {t:TOK.COLON}; i++; continue; }
                            // Celda con letra seguida de nÃºmero, lo manejarÃ¡ el parser combinando ID+NUM o ID+NUM:ID+NUM
                            i++;
                        }
                    }
                    const tokens = Array.from(tokenize(src));
                    let pos = 0;
                    const peek = () => tokens[pos];
                    const consume = () => tokens[pos++];

                    function parse() { return parseExpr(); }
                    function parseExpr() { // suma/resta
                        let node = parseTerm();
                        while (peek() && peek().t === TOK.OP && (peek().v === '+' || peek().v === '-')) {
                            const op = consume().v;
                            const rhs = parseTerm();
                            node = { type:'op', op, args:[node, rhs] };
                        }
                        return node;
                    }
                    function parseTerm() { // mul/div
                        let node = parseFactor();
                        while (peek() && peek().t === TOK.OP && (peek().v === '*' || peek().v === '/')) {
                            const op = consume().v;
                            const rhs = parseFactor();
                            node = { type:'op', op, args:[node, rhs] };
                        }
                        return node;
                    }
                    function parseFactor() {
                        const tk = peek();
                        if (!tk) return { type:'const', value: 0 };
                        if (tk.t === TOK.NUM) { consume(); return { type:'const', value: Number(tk.v) }; }
                        if (tk.t === TOK.ID) {
                            // Puede ser nombre de celda/rango o funciÃ³n
                            const id = consume().v;
                            const next = peek();
                            if (next && next.t === TOK.NUM) {
                                // celda: Ej C2
                                const r1 = consume().v;
                                const base = { col:id, row:r1 };
                                if (peek() && peek().t === TOK.COLON) {
                                    consume();
                                    const id2 = consume();
                                    const r2 = consume();
                                    if (!id2 || id2.t !== TOK.ID || !r2 || r2.t !== TOK.NUM) return { type:'const', value:null };
                                    return cellRangeToAst(base.col, base.row, id2.v, r2.v);
                                }
                                return cellRangeToAst(base.col, base.row, base.col, base.row);
                            }
                            if (next && next.t === TOK.LP) {
                                consume(); // (
                                const args = [];
                                if (peek() && peek().t !== TOK.RP) {
                                    args.push(parse());
                                    while (peek() && peek().t === TOK.COMMA) { consume(); args.push(parse()); }
                                }
                                if (peek() && peek().t === TOK.RP) consume();
                                return { type:id, args };
                            }
                            // Identificador suelto no vÃ¡lido
                            return { type:'const', value: 0 };
                        }
                        if (tk.t === TOK.LP) { consume(); const node = parse(); if (peek() && peek().t === TOK.RP) consume(); return node; }
                        return { type:'const', value: 0 };
                    }

                    function cellRangeToAst(c1, r1, c2, r2) {
                        const colA = XLSX.utils.decode_col(c1);
                        const rowA = parseInt(r1, 10) - 1;
                        const colB = XLSX.utils.decode_col(c2);
                        const rowB = parseInt(r2, 10) - 1;
                        const col = (colA === colB) ? colA : colIdx;
                        const monthsIncl = [];
                        for (let r = Math.min(rowA, rowB); r <= Math.max(rowA, rowB); r++) {
                            const m = rowToMonth[r]; if (m) monthsIncl.push(m);
                        }
                        return { type:'range', c: col, months: monthsIncl };
                    }

                    return parse();
                }

                function evalAst(node) {
                    if (!node) return 0;
                    function valuesOf(n) {
                        if (n.type === 'range') {
                            // Mapear idx de columna Excel a nuestro id por header pos; como la fÃ³rmula proviene de esa misma columna, usamos el id actual
                            // Encontrar id segÃºn col actual en header
                            // Obtenemos por posiciÃ³n: cols estÃ¡n mapeadas al header en el mismo orden importado, pero aquÃ­ usamos el id ya calculado al construir footAst.
                            // En range omitimos c y usamos la columna del AST asignada: se evaluarÃ¡ en compute with data column id externally.
                            // Para simplicidad, el AST de pie fue guardado por columna; por lo tanto tomaremos el id de la columna evaluada desde el cierre superior.
                            return n.months.map(m => parseNum(data[m]?.[currentEvalColId])).filter(v => v !== null);
                        }
                        if (n.type === 'const') return [n.value];
                        return [evalAst(n)];
                    }
                    let currentEvalColId = evalAst.currentColId || null;
                    switch (node.type) {
                        case 'SUM':
                        case 'SUMA': {
                            const vals = node.args.flatMap(valuesOf);
                            return vals.reduce((a,b)=>a+(Number.isFinite(b)?b:0),0);
                        }
                        case 'AVERAGE':
                        case 'PROMEDIO': {
                            const vals = node.args.flatMap(valuesOf).filter(v => Number.isFinite(v));
                            return vals.length ? vals.reduce((a,b)=>a+b,0)/vals.length : 0;
                        }
                        case 'MAX': {
                            const vals = node.args.map(a => {
                                const arr = valuesOf(a).filter(v => Number.isFinite(v));
                                if (!arr.length) return 0; return Math.max(...arr);
                            });
                            return vals.length ? Math.max(...vals) : 0;
                        }
                        case 'MIN': {
                            const vals = node.args.map(a => {
                                const arr = valuesOf(a).filter(v => Number.isFinite(v));
                                if (!arr.length) return 0; return Math.min(...arr);
                            });
                            return vals.length ? Math.min(...vals) : 0;
                        }
                        case 'op': {
                            const [a, b] = node.args || [];
                            const av = evalAst(a);
                            const bv = evalAst(b);
                            switch (node.op) {
                                case '+': return (av || 0) + (bv || 0);
                                case '-': return (av || 0) - (bv || 0);
                                case '*': return (av || 0) * (bv || 0);
                                case '/': return (bv ? (av || 0) / bv : 0);
                                default: return 0;
                            }
                        }
                        default: {
                            // Si el nodo raÃ­z es range/const
                            const arr = valuesOf(node).filter(v => Number.isFinite(v));
                            return arr.length ? arr[0] : 0;
                        }
                    }
                }

                // Override evalAst with extended support for row-level formulas
                function evalAst(node) {
                    if (!node) return 0;
                    function valuesOf(n) {
                        if (n.type === 'range') {
                            return n.months.map(m => parseNum(data[m]?.[evalAst.currentColId])).filter(v => v !== null);
                        }
                        if (n.type === 'rowCell') {
                            const monthId = evalAst.currentMonthId;
                            const id = n.colId;
                            const v = parseNum(data[monthId]?.[id]);
                            return v === null ? [] : [v];
                        }
                        if (n.type === 'rowRange') {
                            const monthId = evalAst.currentMonthId;
                            const arr = [];
                            for (const id of n.cols || []) {
                                const v = parseNum(data[monthId]?.[id]);
                                if (v !== null) arr.push(v);
                            }
                            return arr;
                        }
                        if (n.type === 'const') return [n.value];
                        return [evalAst(n)];
                    }
                    switch (node.type) {
                        case 'SUM':
                        case 'SUMA': {
                            const vals = node.args.flatMap(valuesOf);
                            return vals.reduce((a,b)=>a+(Number.isFinite(b)?b:0),0);
                        }
                        case 'AVERAGE':
                        case 'PROMEDIO': {
                            const vals = node.args.flatMap(valuesOf).filter(v => Number.isFinite(v));
                            return vals.length ? vals.reduce((a,b)=>a+b,0)/vals.length : 0;
                        }
                        case 'MAX': {
                            const vals = node.args.map(a => {
                                const arr = valuesOf(a).filter(v => Number.isFinite(v));
                                if (!arr.length) return 0; return Math.max(...arr);
                            });
                            return vals.length ? Math.max(...vals) : 0;
                        }
                        case 'MIN': {
                            const vals = node.args.map(a => {
                                const arr = valuesOf(a).filter(v => Number.isFinite(v));
                                if (!arr.length) return 0; return Math.min(...arr);
                            });
                            return vals.length ? Math.min(...vals) : 0;
                        }
                        case 'op': {
                            const [a, b] = node.args || [];
                            const av = evalAst(a);
                            const bv = evalAst(b);
                            switch (node.op) {
                                case '+': return (av || 0) + (bv || 0);
                                case '-': return (av || 0) - (bv || 0);
                                case '*': return (av || 0) * (bv || 0);
                                case '/': return (bv ? (av || 0) / bv : 0);
                                default: return 0;
                            }
                        }
                        default: {
                            const arr = valuesOf(node).filter(v => Number.isFinite(v));
                            return arr.length ? arr[0] : 0;
                        }
                    }
                }

                function recomputeRow(monthId) {
                    if (!formulaCfg || !formulaCfg.rowAst) return;
                    let changed = false;
                    for (const colId in formulaCfg.rowAst) {
                        try {
                            evalAst.currentColId = colId;
                            evalAst.currentMonthId = monthId;
                            const val = String(evalAst(formulaCfg.rowAst[colId]));
                            if (!data[monthId]) data[monthId] = {};
                            data[monthId][colId] = val;
                            changed = true;
                            const input = gridBody.querySelector(`input.grid-input[data-month="${monthId}"][data-field="${colId}"]`);
                            if (input) input.value = val;
                        } finally {
                            evalAst.currentColId = null;
                            evalAst.currentMonthId = null;
                        }
                    }
                    if (changed) save();
                }

                function parseCSV(text) {
                    const rows = [];
                    let i = 0, field = '', row = [], inQuotes = false;
                    while (i < text.length) {
                        const ch = text[i++];
                        if (inQuotes) {
                            if (ch === '"') {
                                if (text[i] === '"') { field += '"'; i++; }
                                else { inQuotes = false; }
                            } else { field += ch; }
                        } else {
                            if (ch === '"') { inQuotes = true; }
                            else if (ch === ',') { row.push(field); field = ''; }
                            else if (ch === '\n') { row.push(field); rows.push(row); row = []; field = ''; }
                            else if (ch === '\r') { /* ignore */ }
                            else { field += ch; }
                        }
                    }
                    row.push(field); rows.push(row);
                    return rows.filter(r => r.some(c => String(c).trim() !== ''));
                }

                function applyImportedRows(rows) {
                    if (!rows.length) return;
                    // Encuentra fila de encabezados que contenga 'MES'
                    let headerRowIndex = 0;
                    for (let r = 0; r < Math.min(rows.length, 15); r++) {
                        const rn = (rows[r] || []).map(normalizeLabel);
                        if (rn.includes('MES')) { headerRowIndex = r; break; }
                    }
                    const headerRaw = (rows[headerRowIndex] || []).map(h => String(h ?? ''));
                    const header = headerRaw.map(normalizeLabel);
                    const idxMes = header.findIndex(h => h === 'MES');
                    if (idxMes === -1) throw new Error('No se encontrÃ³ la columna MES.');

                    // Mapeo y actualizaciÃ³n de encabezados visibles
                    const wantMap = Object.fromEntries(baseCols.map(c => [normalizeLabel(c.label), c.id]));
                    const colIndexById = {};
                    const newCols = [];
                    for (let c = 0; c < header.length; c++) {
                        const norm = header[c];
                        if (norm === 'MES' || norm === 'TOTALES') continue;
                        const id = wantMap[norm];
                        if (id) {
                            colIndexById[id] = c;
                            const base = baseCols.find(x => x.id === id);
                            newCols.push({ ...base, label: headerRaw[c] || base.label });
                        }
                    }
                    // Si faltan columnas conocidas, agrÃ©galas al final
                    for (const bc of baseCols) {
                        if (!newCols.some(x => x.id === bc.id)) newCols.push(bc);
                    }
                    cols = newCols;
                    const idxTot = header.findIndex(h => h === 'TOTALES');
                    totalsHeaderLabel = idxTot >= 0 ? headerRaw[idxTot] : 'TOTALES';
                    try { saveTotalsLabel(); } catch {}
                    formulaCfg = formulaCfg || {};
                    formulaCfg.headerRaw = headerRaw;
                    try { saveFormula(); } catch {}

                    const monthAlias = {
                        'ENE': 'ENE', 'ENERO': 'ENE',
                        'FEB': 'FEB', 'FEBRERO': 'FEB',
                        'MAR': 'MAR', 'MARZO': 'MAR',
                        'ABR': 'ABR', 'ABRIL': 'ABR',
                        'MAY': 'MAY', 'MAYO': 'MAY',
                        'JUN': 'JUN', 'JUNIO': 'JUN', 'JUNSAC': 'JUN_SAC', 'JUN+SAC': 'JUN_SAC',
                        'JUL': 'JUL', 'JULIO': 'JUL',
                        'AGO': 'AGO', 'AGOSTO': 'AGO',
                        'SEP': 'SEPT', 'SEPT': 'SEPT', 'SEPTIEMBRE': 'SEPT',
                        'OCT': 'OCT', 'OCTUBRE': 'OCT',
                        'NOV': 'NOV', 'NOVIEMBRE': 'NOV',
                        'DIC': 'DIC', 'DICIEMBRE': 'DIC', 'DICSAC': 'DIC_SAC', 'DIC+SAC': 'DIC_SAC'
                    };

                    for (let r = (function(){ let hr=0; for(let i=0;i<Math.min(rows.length,15);i++){ const rn=(rows[i]||[]).map(normalizeLabel); if (rn.includes('MES')) { hr=i; break; } } return hr+1; })(); r < rows.length; r++) {
                        const rawRow = rows[r];
                        if (!rawRow || !rawRow.length) continue;
                        const mesRaw = String(rawRow[idxMes] ?? '').trim();
                        const mesKey = monthAlias[normalizeLabel(mesRaw)];
                        if (!mesKey || mesKey === 'JUN' || mesKey === 'DIC') {
                            // Si es JUN o DIC a secas lo ignoramos (usamos JUN+SAC/DIC+SAC)
                            if (normalizeLabel(mesRaw) === 'PROMEDIO') continue;
                            continue;
                        }
                        if (!data[mesKey]) data[mesKey] = {};
                        for (const col of cols) {
                            const ci = colIndexById[col.id];
                            if (ci == null) continue;
                            const val = rawRow[ci] ?? '';
                            data[mesKey][col.id] = String(val).trim();
                        }
                    }
                }
            })();
        </script>
    </section>
</body>
</html>





